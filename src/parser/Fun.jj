/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  STATIC = false; // permite mais de um AL e AS, o que da flexibilidade
}

PARSER_BEGIN(Fun)
package parser;
  import java.io.*;

public class Fun{
  
  final static String Version = "Fun compiler - version 1.0";
  boolean Menosshort = false; //saida resumida = falso

  public static void main(String args []) throws ParseException {
    String filename = ""; // nome do arquivo analisado
    Fun parser; // analisador lexico
    int i;
    boolean ms = false;
    
    System.out.println(Version); //le os parametros passados para o compilador

    for (i=0; i<args.length - 1; i++)
    {
      if( args[i].toLowerCase().equals("-short") )
      	ms = true;
      else
      {
		System.out.println("inputfile");
		System.exit(0);
      }
  	}

  	if (args[i].equals("-"))
  	{ 	//le da entrada padrao
      System.out.println("Reading from standard input...");
      parser = new Fun(System.in);
  	}
  	else
  	{	// le do arquivo
		filename = args[args.length-1];
		System.out.println("Reading from file " + filename);
		try {
		  parser = new Fun(new java.io.FileInputStream(filename));
		}
		catch (java.io.FileNotFoundException e) {
		  System.out.println("File not found");
		  return;
		}
  	}
  	parser.Menosshort = ms;
  	parser.program(); //chama metodo que faz analise

  	//verifica se houve erro lexico

  if (parser.token_source.foundLexError() != 0 )
  	System.out.println( parser.token_source.foundLexError() + " Lexical errors found");

  else
  	System.out.println("Program successfully analized.");
} // main

static public String im(int x) //metodo auxiliar
{
  int k;
  String s;
  	s = tokenImage[x];
  	k = s.lastIndexOf("\"");
  	try { s=s.substring(1,k); }
  	catch (StringIndexOutOfBoundsException e)
  	{ }
  	return s;
 }

} //FUN


PARSER_END(Fun)

TOKEN_MGR_DECLS :
{
  int countLexError = 0;

  public int foundLexError() {
    return countLexError;
  }

}

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "\f"
}

SKIP :
{
	"/*": multilinecomment
}


< multilinecomment > SKIP:
{
	"*/" : DEFAULT
| 	< ~[] >
}

SKIP :
{
	"//": singlelinecomment
}

< singlelinecomment > SKIP:
{
	<["\n","\r"]> : DEFAULT
| 	< ~[] >
}

SPECIAL_TOKEN:
{
< INVALID_LEXICAL:
(~ ["a"-"z", "A"-"Z",
	"0"-"9",
	"\"",
	"(",
	")",
	"[",
	"]",
	"{",
	"}",
	";",
	",",
	".",
	"=",
	"<",
	">",
	"!",
	"+",
	"-",
	"*",
	"/",
	"%",
	" ",
	"\t",
	"\n",
	"\r",
	"\f"
	])+ >
		{
		  System.err.println("Line " + input_stream.getEndLine()+ " - Invalid string found: " +image);
		  countLexError++;
		}
|
	< INVALID_CONST:
	"\"" (~ ["\n", "\r", "\""])* ["\n", "\r"] >
	{
	  	System.err.println("Line " + input_stream.getEndLine() + " - String constant has a \\n: " + image);

	  	countLexError++;
	 }

}
		  

TOKEN : /* Palavras Reservadas */
{
  < BREAK: "break" >
| < CLASS: "class" >
| < CONSTRUCTOR: "constructor" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FOR: "for" >
| < IF: "if" >
| < INT: "int" >
| < NEW: "new" >
| < PRINT: "print" >
| < READ: "read" >
| < RETURN: "return" >
| < STRING: "string" >
| < SUPER: "super" >
}


TOKEN : /* Operadores */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NEQ: "!=" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < REM: "%" >
}

TOKEN : /* Operadores */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN : /* Constantes*/
{
  < int_constant: (
    (["0"-"9"] (["0"-"9"])* ) |
	(["0"-"7"] (["0"-"7"])* ["o", "O"] ) |
	(["0"-"9"] (["0"-"7","A"-"F","a"-"f"])* ["h", "H"] ) |
	(["0"-"1"] (["0"-"1"])* ["b","B"])
   ) >
|
	<  string_constant:		//constante string como "abcd"
		"\""( ~ ["\"","n", "\r"])* "\"" >
}

TOKEN : /* identificadores*/
{
  < INDENT: < LETTER > (< LETTER >|< DIGIT >)* >
|
  < #LETTER:["A"-"Z","a"-"z"] >
|
  < #DIGIT:["0"-"9"] >
}


TOKEN : /* LITERALS */
{
  
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])*
  >
  
| < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
| < BOOLEAN: "true" | "false">
| < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

void program() :
{}
{
  (
    <PLUS> { System.out.println("Reconheceu PLUS"); } 
  | <MINUS> { System.out.println("Reconheceu MINUS"); } 
  | <STAR> { System.out.println("Reconheceu STAR"); } 
  | <SLASH> { System.out.println("Reconheceu SLASH"); }  
  )*
} 

void BooleanLiteral() :
{}
{
  "true"
|
  "false"
}
